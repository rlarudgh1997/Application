/**
 *
 * Copyright (c) 2016  Hyundai Motor Company,
 * All Rights Reserved.
 *
 * Use and copying of this software and preparation of derivative works
 * based upon this software are permitted. Any copy of this software or
 * of any derivative work must include the above copyright notice, this
 * paragraph and the one after it. Any distribution of this software or
 * derivative works must comply with all applicable laws.
 *
 * This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
 * ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
 * LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
 * EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
 * NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGES.
 */
// Auto generated file : Do not edit this file.

#ifndef HVEHICLE_VSMNODE_HEADER
#define HVEHICLE_VSMNODE_HEADER

#include <string>
#include <vector>
#include <map>
#include <complex>
#include <Node.hpp>

namespace VSM {

/**
 * @brief VSMNode class.
 * @details This class is base for VSM Abstract Class.
 */
class VSMNode : public Node {
public:
    /**
     * @brief Disable copy constructor.
     */
    VSMNode(const VSMNode&) = delete;
    /**
     * @brief Disable move constructor.
     */
    VSMNode(VSMNode&&) = delete;
    /**
     * @brief Disable copy assignment operator.
     */
    const VSMNode& operator=(const VSMNode&) = delete;
    /**
     * @brief Disable move assignment operator.
     */
    const VSMNode& operator=(VSMNode&&) = delete;

    inline bool operator==(const VSMNode& rhs) const {
        return equals(rhs);
    }

    friend std::ostream& operator<<(std::ostream& os, const VSMNode& rhs);

    /**
     * @brief Gets the description.
     * @return std::string : description field of vsm.
     */
    virtual std::string getDescription() const {
        return "";
    }
    /**
     * @brief Gets the node type.
     * @details type : actuator, branch, sensor, multi.
     * @return std::string : type field of vsm.
     */
    virtual std::string getNodeType() const {
        return "";
    }

#if defined(SSFS_INTERNAL) || defined(SSFS_VALIDATOR)
    /**
     * @brief Gets the factor value.
     * @details usingCorrection is true : use getFactor.
     * @details default 1.
     * @return HDouble : factor field of vsm.
     */
    virtual ccos::HDouble getFactor() {
        return 1.;
    }
    /**
     * @brief Gets the offset value.
     * @details usingCorrection is true : use getOffset.
     * @details default 0.
     * @return HInt64 : offset field of vsm.
     */
    virtual ccos::HInt64 getOffset() {
        return 0;
    }
    /**
     * @brief Check if the value is to be modified.
     * @return true factor and offset are not default, false not use factor and offset.
     */
    virtual bool usingCorrection() {
        return false;
    }
    /**
     * @brief Gets the mask value.
     * @details usingMask is true : use getMask.
     * @details default 0xffffffffffffffff.
     * @return HInt64 : mask field of vsm.
     */
    virtual ccos::HUInt64 getMask() {
        return 0xffffffffffffffff;
    }
    /**
     * @brief Gets the shift value.
     * @details valid if usingMask is true
     * @details default value is 0
     * @return HInt64 : positive value is using << operator, otherwise >> operator
     */
    virtual ccos::HInt64 getShift() {
        return 0;
    }
    /**
     * @brief Check if the value is to be masked.
     * @return true factor and mask are not default, false not use factor and mask.
     */
    virtual bool usingMask() {
        return false;
    }
#endif  // SSFS_INTERNAL

protected:
    /**
     * @brief The constructor of VSMNode.
     * @param[in] address vehicle signal node path
     * @param[in] signalName vehicle signal name
     */
    VSMNode(const NodeAddress& address, const SignalName& signalName) : Node(address, signalName) {
    }
    /**
     * @brief The destuctor of VSMNode
     */
    virtual ~VSMNode() = default;

    /**
     * @brief Gets the min value.
     * @details hasRange is true : use getMinValue.
     * @return HInt64 : min field of vsm.
     */
    virtual ccos::HInt64 getMinValue() {
        return 0;
    }
    /**
     * @brief Gets the max value.
     * @details hasRange is true : use getMaxValue.
     * @return HInt64 : max field of vsm.
     */
    virtual ccos::HInt64 getMaxValue() {
        return 0;
    }
    /**
     * @brief Check if min and max ranges exist.
     * @return true min and max are exist, false min and max are not exist.
     */
    virtual bool hasRange() {
        return false;
    }
    /**
     * @brief Calculate and return the value corresponding to NodeAddress.
     * @details If SignalName has multiple NodeAddress, calculate the bit value corresponding to NodeAddress.
     * @param[in] value HUInt64 : The SignalName value.
     * @return HUInt64 : The NodeAddress value.
     */
    virtual ccos::HUInt64 calculateValue(ccos::HUInt64& value) {
        return value;
    }

    static constexpr uint64_t kUINT64_MAX = 0xFFFFFFFF;
    static constexpr uint64_t kTimeOut = kUINT64_MAX;
};

inline std::ostream& operator<<(std::ostream& os, const VSMNode& rhs) {
    os << rhs.getAddress();
    return os;
}

inline bool operator==(const std::string& lhs, const VSMNode& rhs) {
    return lhs == rhs.getAddress();
}
}  // namespace VSM
#endif  // HVEHICLE_VSMNODE_HEADER
